
# Macros:
#% macro, P, Device Prefix
#% macro, R, Device Suffix
#% macro, PORT, Asyn Port name
#% macro, TIMEOUT, Timeout
#% macro, ADDR, Asyn Port address

# This associates the template with an edm screen
# % gui, $(PORT), edmtab, pcoDetector.edl, P=$(P),R=$(R)

# All tags starting with gdatag are DLS specific for GDA
# % gdatag, template, pcocam, $(PORT)_pcocam, $(PORT) pcocam class instance

# Only 1 data type is supported, unsigned 16 bit integers
record(mbbo, "$(P)$(R)DataType")
{
   field(ZRST, "UInt16")
   field(ZRVL, "3")
   field(ONST, "")
   field(ONVL, "")
   field(TWST, "")
   field(TWVL, "")
   field(THST, "")
   field(THVL, "")
   field(FRST, "")
   field(FRVL, "")
   field(FVST, "")
   field(FVVL, "")
   field(SXST, "")
   field(SXVL, "")
   field(SVST, "")
   field(SVVL, "")
}

record(mbbi, "$(P)$(R)DataType_RBV")
{
   field(ZRST, "UInt16")
   field(ZRVL, "3")
   field(ONST, "")
   field(ONVL, "")
   field(TWST, "")
   field(TWVL, "")
   field(THST, "")
   field(THVL, "")
   field(FRST, "")
   field(FRVL, "")
   field(FVST, "")
   field(FVVL, "")
   field(SXST, "")
   field(SXVL, "")
   field(SVST, "")
   field(SVVL, "")
}

# Overwrite ADBase.template TriggerMode definition strings
record(mbbo, "$(P)$(R)TriggerMode")
{
    field(ZRST, "Auto")
    field(ZRVL, "0")
    field(ONST, "Soft")
    field(ONVL, "1")
    field(TWST, "Ext + Soft")
    field(TWVL, "2")
    field(THST, "Ext Pulse")
    field(THVL, "3")
    field(FRST, "Ext Only")
    field(FRVL, "5")
}
record(mbbi, "$(P)$(R)TriggerMode_RBV")
{
    field(ZRST, "Auto")
    field(ZRVL, "0")
    field(ONST, "Soft")
    field(ONVL, "1")
    field(TWST, "Ext + Soft")
    field(TWVL, "2")
    field(THST, "Ext Pulse")
    field(THVL, "3")
    field(FRST, "Ext Only")
    field(FRVL, "5")
}

# % gdatag, pv, rw, $(PORT)_pcocam, PIX_RATE, Set pixel rate
record(mbbo, "$(P)$(R)PIX_RATE")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_PIX_RATE")
    field(VAL, "0")
    field(ZRST, "Unset")
    field(ZRVL, 0)
}

# % gdatag, pv, ro, $(PORT)_pcocam, PIX_RATE_RBV, Readback for pixel rate
record(mbbi, "$(P)$(R)PIX_RATE_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_PIX_RATE")
    field(SCAN, "I/O Intr")
    field(ZRST, "Unset")
    field(ZRVL, 0)
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, ADC_MODE, Set adc mode
record(mbbo, "$(P)$(R)ADC_MODE") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ADC_MODE")
    field(ZRST, "One ADC")
    field(ZRVL, "1")
    field(ONVL, "2")
    field(ONST, "Two ADC")
    field(IVOA, "Don't drive outputs")
    field(VAL,  "1")
    field(PINI, "YES")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, ADC_MODE_RBV, Readback for adc mode
record(mbbi, "$(P)$(R)ADC_MODE_RBV") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ADC_MODE")
    field(ZRST, "One ADC")
    field(ZRVL, "1")
    field(ONVL, "2")
    field(ONST, "Two ADC")
    field(SCAN, "I/O Intr")
}

# % gdatag, pv, ro, $(PORT)_pcocam, CAM_RAM_USE_RBV, Readback for cam ram usage
record(ai, "$(P)$(R)CAM_RAM_USE_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAM_RAM_USE")
    field(PREC, "0")
    field(EGU, "%")
    field(SCAN, "I/O Intr")
}

# % gdatag, pv, ro, $(PORT)_pcocam, CAM_RAM_USE_FRAMES_RBV, Readback for cam ram usage
record(ai, "$(P)$(R)CAM_RAM_USE_FRAMES_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAM_RAM_USE_FRAMES")
    field(PREC, "0")
    field(SCAN, "I/O Intr")
}

# % gdatag, pv, ro, $(PORT)_pcocam, ELEC_TEMP_RBV, Readback for elec temp
record(ai, "$(P)$(R)ELEC_TEMP_RBV") 
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ELECTRONICS_TEMP")
    field(PREC, "0")
    field(EGU, "C")
    field(SCAN, "I/O Intr")
}

# % gdatag, pv, ro, $(PORT)_pcocam, POWER_TEMP_RBV, Readback for power temp
record(ai, "$(P)$(R)POWER_TEMP_RBV") 
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_POWER_TEMP")
    field(PREC, "0")
    field(EGU, "C")
    field(SCAN, "I/O Intr")
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, STORAGE_MODE, Set storage mode
record(mbbo, "$(P)$(R)STORAGE_MODE") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_STORAGE_MODE")
    field(ZRST, "Recorder")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(ONST, "FIFO buffer")
    field(IVOA, "Don't drive outputs")
    field(VAL,  "0")
    field(PINI, "YES")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, STORAGE_MODE_RBV, Readback for storage mode
record(mbbi, "$(P)$(R)STORAGE_MODE_RBV") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_STORAGE_MODE")
    field(ZRST, "Recorder")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(ONST, "FIFO buffer")
    field(SCAN, "I/O Intr")
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, RECORDER_MODE, Set recorder mode
record(mbbo, "$(P)$(R)RECORDER_MODE") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_RECORDER_SUBMODE")
    field(ZRST, "Sequence")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(ONST, "Ring buffer")
    field(IVOA, "Don't drive outputs")
    field(VAL,  "1")
    field(PINI, "YES")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, RECORDER_MODE_RBV, Readback for recorder mode
record(mbbi, "$(P)$(R)RECORDER_MODE_RBV") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_RECORDER_SUBMODE")
    field(ZRST, "Sequence")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(ONST, "Ring buffer")
    field(SCAN, "I/O Intr")
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, TIMESTAMP_MODE, Set timestamp mode
record(mbbo, "$(P)$(R)TIMESTAMP_MODE") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_TIMESTAMP_MODE")
    field(ZRST, "None")
    field(ONST, "BCD")
    field(TWST, "BCD+ASCII")
    field(THST, "ASCII")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(IVOA, "Don't drive outputs")
    field(VAL,  "2")
    field(PINI, "YES")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, TIMESTAMP_MODE_RBV, Readback for timestamp mode
record(mbbi, "$(P)$(R)TIMESTAMP_MODE_RBV") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_TIMESTAMP_MODE")
    field(ZRST, "None")
    field(ONST, "BCD")
    field(TWST, "BCD+ASCII")
    field(THST, "ASCII")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(THVL, "3")
    field(SCAN, "I/O Intr")
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, ACQUIRE_MODE, Set acquire mode
record(mbbo, "$(P)$(R)ACQUIRE_MODE") 
{
    field(DESC, "mode select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ACQUIRE_MODE")
    field(ZRST, "Auto")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(ONST, "Ext. enable")
    field(TWST, "Ext. trigger")
    field(IVOA, "Don't drive outputs")
    field(VAL,  "0")
    field(PINI, "YES")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, ACQUIRE_MODE_RBV, Readback for acquire mode
record(mbbi, "$(P)$(R)ACQUIRE_MODE_RBV") 
{
    field(DESC, "acquire mode select")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ACQUIRE_MODE")
    field(ZRST, "Auto")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(TWVL, "2")
    field(ONST, "Ext. enable")
    field(TWST, "Ext. trigger")
    field(SCAN, "I/O Intr")
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, ARM_MODE, Set arm mode
record(bo, "$(P)$(R)ARM_MODE")
{
    field(DESC, "arm mode select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ARM_MODE")
    field(ZNAM, "Disarmed")
    field(ONAM, "Armed")
    field(VAL,  "0")
    field(PINI, "YES")
	field(FLNK, "$(P)$(R)ARM_STARTBUSY")
}

# These records keep the ARM_MODE busy until it has completed
record(calcout, "$(P)$(R)ARM_STARTBUSY")
{
	field(INPA, "$(P)$(R)ARM_MODE")
	field(CALC, "A")
	field(OOPT, "Transition To Non-zero")
	field(DOPT, "Use OCAL")
    field(OCAL, "1")
	field(OUT,  "$(P)$(R)ARM_BUSY PP")
}
record(busy, "$(P)$(R)ARM_BUSY")
{
    field(ZNAM, "Idle")
    field(ONAM, "Arming")
    field(VAL,  "0")
}
record(bi, "$(P)$(R)ARM_COMPLETE")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ARM_COMPLETE")
    field(SCAN, "I/O Intr")
	field(FLNK, "$(P)$(R)ARM_ENDBUSY")
}
record(dfanout, "$(P)$(R)ARM_ENDBUSY")
{
    field(DOL,  "0")
	field(OUTA, "$(P)$(R)ARM_BUSY CA")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, ARM_MODE_RBV, Readback for arm mode
record(bi, "$(P)$(R)ARM_MODE_RBV")
{
    field(DESC, "arm mode select")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ARM_MODE")
    field(ZNAM, "Disarmed")
    field(ONAM, "Armed")
    field(SCAN, "I/O Intr")
}

# % gdatag, pv, rw, $(PORT)_pcocam, DELAY_TIME, Set delay time
record(ao, "$(P)$(R)DELAY_TIME") 
{
    field(DTYP, "asynFloat64")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_DELAY_TIME")
    field(VAL, "0")
    field(PREC, "6")
    field(EGU,  "")
}

# % gdatag, pv, ro, $(PORT)_pcocam, DELAY_TIME_RBV, Readback for delay time
record(ai, "$(P)$(R)DELAY_TIME_RBV") 
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_DELAY_TIME")
    field(PREC, "6")
    field(EGU, "")
    field(SCAN, "I/O Intr")
}

# % gdatag, pv, ro, $(PORT)_pcocam, IMAGE_NUMBER_RBV, Readback for image number
record(ai, "$(P)$(R)IMAGE_NUMBER_RBV") 
{
    field(PINI, "YES")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_IMAGE_NUMBER")
    field(PREC, "0")
    field(EGU, "")
    field(SCAN, "I/O Intr")
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, CAMERA_SETUP, Set camera shutter setup
record(mbbo, "$(P)$(R)CAMERA_SETUP") 
{
    field(DESC, "shutter mode select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAMERA_SETUP")
    field(ZRST, "Rolling Shutter")
    field(ZRVL, "1")
    field(ONVL, "2")
    field(ONST, "Global Shutter")
    field(IVOA, "Don't drive outputs")
    field(VAL,  "0")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, CAMERA_SETUP_RBV, Readback for camera shutter setup
record(mbbi, "$(P)$(R)CAMERA_SETUP_RBV") 
{
    field(DESC, "shutter mode readback")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAMERA_SETUP")
    field(ZRST, "Rolling Shutter")
    field(ZRVL, "1")
    field(ONVL, "2")
    field(ONST, "Global Shutter")
    field(SCAN, "I/O Intr")
}

# % gdatag, mbbinary, rw, $(PORT)_pcocam, BIT_ALIGNMENT, Set camera bit alignment
record(mbbo, "$(P)$(R)BIT_ALIGNMENT") 
{
    field(DESC, "bit alignment select")
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_BIT_ALIGNMENT")
    field(ZRST, "MSB")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(ONST, "LSB")
    field(IVOA, "Don't drive outputs")
}

# % gdatag, mbbinary, ro, $(PORT)_pcocam, BIT_ALIGNMENT_RBV, Readback for camera bit alignment
record(mbbi, "$(P)$(R)BIT_ALIGNMENT_RBV") 
{
    field(DESC, "bit alignment readback")
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_BIT_ALIGNMENT")
    field(ZRST, "MSB")
    field(ZRVL, "0")
    field(ONVL, "1")
    field(ONST, "LSB")
    field(SCAN, "I/O Intr")
}

# State record
record(stringin, "$(P)$(R)STATE_RECORD_RBV")
{
    field(DTYP, "asynOctetRead")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_STATERECORD")
    field(SCAN, "I/O Intr")
}

# Clear the state record
record(longout, "$(P)$(R)CLEAR_STATE_RECORD")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CLEARSTATERECORD")
}

# Error counter, out of ND arrays
record(longin, "$(P)$(R)OUTOFNDARRAYS_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_OUTOFNDARRAYS")
    field(SCAN, "I/O Intr")
}

# Error counter, missing frames
record(longin, "$(P)$(R)MISSINGFRAMES_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_MISSINGFRAMES")
    field(SCAN, "I/O Intr")
}

# Error counter, DRIVERLIBRARYERRORS
record(longin, "$(P)$(R)DRIVERLIBRARYERRORS_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_DRIVERLIBRARYERRORS")
    field(SCAN, "I/O Intr")
}

# Hardware binning X
record(longin, "$(P)$(R)HWBINX_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_HWBINX")
    field(SCAN, "I/O Intr")
}

# Hardware binning Y
record(longin, "$(P)$(R)HWBINY_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_HWBINY")
    field(SCAN, "I/O Intr")
}

# Hardware ROI X1
record(longin, "$(P)$(R)HWROIX1_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_HWROIX1")
    field(SCAN, "I/O Intr")
}

# Hardware ROI Y1
record(longin, "$(P)$(R)HWROIY1_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_HWROIY1")
    field(SCAN, "I/O Intr")
}

# Hardware ROI X2
record(longin, "$(P)$(R)HWROIX2_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_HWROIX2")
    field(SCAN, "I/O Intr")
}

# Hardware ROI Y2
record(longin, "$(P)$(R)HWROIY2_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_HWROIY2")
    field(SCAN, "I/O Intr")
}

# Hardware image size X
record(longin, "$(P)$(R)XCAMSIZE_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_XCAMSIZE")
    field(SCAN, "I/O Intr")
}

# Hardware image size Y
record(longin, "$(P)$(R)YCAMSIZE_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_YCAMSIZE")
    field(SCAN, "I/O Intr")
}

# Camlink clock rate
record(longin, "$(P)$(R)CAMLINKCLOCK_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAMLINKCLOCK")
    field(SCAN, "I/O Intr")
    field(EGU, "Hz")
}

# Parameters that are not implemented and are disabled to remove them
# from the GUI.
record(ao, "$(P)$(R)Gain")
{
   field(DISA, "1")
}
record(mbbo, "$(P)$(R)ColorMode")
{
   field(DISA, "1")
}
record(ai, "$(P)$(R)Gain_RBV")
{
   field(DISA, "1")
}
record(bo, "$(P)$(R)ReverseX") 
{
  field(DISA, "1")
}
record(bo, "$(P)$(R)ReverseY") 
{
  field(DISA, "1")
}

# CCD Cooling parameters

record(ai, "$(P)$(R)MINCOOLINGSETPOINT_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_MINCOOLINGSETPOINT")
    field(PREC, "0")
    field(EGU, "C")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)MAXCOOLINGSETPOINT_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_MAXCOOLINGSETPOINT")
    field(PREC, "0")
    field(EGU, "C")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)DEFAULTCOOLINGSETPOINT_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_DEFAULTCOOLINGSETPOINT")
    field(PREC, "0")
    field(EGU, "C")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)COOLINGSETPOINT_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_COOLINGSETPOINT")
    field(PREC, "0")
    field(EGU, "C")
    field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)COOLINGSETPOINT")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_COOLINGSETPOINT")
    field(VAL, "0")
    field(PREC, "0")
    field(EGU,  "C")
}

# Exposure control parameter ranges

record(ai, "$(P)$(R)DELAYTIMEMIN_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_DELAYTIMEMIN")
    field(PREC, "4")
    field(EGU, "s")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)DELAYTIMEMAX_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_DELAYTIMEMAX")
    field(PREC, "4")
    field(EGU, "s")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)DELAYTIMESTEP_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_DELAYTIMESTEP")
    field(PREC, "4")
    field(EGU, "s")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)EXPTIMEMIN_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_EXPTIMEMIN")
    field(PREC, "4")
    field(EGU, "s")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)EXPTIMEMAX_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_EXPTIMEMAX")
    field(PREC, "4")
    field(EGU, "s")
    field(SCAN, "I/O Intr")
}

record(ai, "$(P)$(R)EXPTIMESTEP_RBV")
{
    field(DTYP, "asynFloat64")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_EXPTIMESTEP")
    field(PREC, "4")
    field(EGU, "s")
    field(SCAN, "I/O Intr")
}

# Binning and ROI capabilities

record(longin, "$(P)$(R)MAXBINHORZ_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_MAXBINHORZ")
    field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)MAXBINVERT_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_MAXBINVERT")
    field(SCAN, "I/O Intr")
}

record(bi, "$(P)$(R)BINHORZSTEPPING_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_BINHORZSTEPPING")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Binary")
    field(ONAM, "Linear")
}

record(bi, "$(P)$(R)BINVERTSTEPPING_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_BINVERTSTEPPING")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Binary")
    field(ONAM, "Linear")
}

record(longin, "$(P)$(R)ROIHORZSTEPS_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ROIHORZSTEPS")
    field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)ROIVERTSTEPS_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ROIVERTSTEPS")
    field(SCAN, "I/O Intr")
}

# Extend the precision of the acquisition time PVs
record(ao, "$(P)$(R)AcquireTime")
{
   field(PREC, "5")
}
record(ai, "$(P)$(R)AcquireTime_RBV")
{
   field(PREC, "5")
}

# Extend the precision of the acquisition period PVs
record(ao, "$(P)$(R)AcquirePeriod")
{
   field(PREC, "5")
}
record(ai, "$(P)$(R)AcquirePeriod_RBV")
{
   field(PREC, "5")
}

# Reboot command
record(bo, "$(P)$(R)REBOOT")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_REBOOT")
    field(ZNAM, "Running")
    field(ONAM, "Booting")
}
record(bi, "$(P)$(R)REBOOT_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_REBOOT")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Running")
    field(ONAM, "Booting")
}

# Camlink Long Gap mode
record(bo, "$(P)$(R)CAMLINKLONGGAP")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAMLINKLONGGAP")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
}
record(bi, "$(P)$(R)CAMLINKLONGGAP_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAMLINKLONGGAP")
    field(SCAN, "I/O Intr")
    field(ZNAM, "Disabled")
    field(ONAM, "Enabled")
}

# The gang mode
record(mbbi, "$(P)$(R)GANGMODE_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_GANGMODE")
    field(SCAN, "I/O Intr")
    field(ZRST, "None")
    field(ZRVL, "0")
    field(ONST, "Server")
    field(ONVL, "1")
    field(TWST, "Connection")
    field(TWVL, "2")
}

# % gdatag, pv, ro, $(PORT)_pcocam, CAM_RAM_RBV, Camera RAM size
record(longin, "$(P)$(R)CAM_RAM_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAM_RAM")
    field(EGU, "MBytes")
    field(SCAN, "I/O Intr")
}

# Camera busy
record(mbbi, "$(P)$(R)CAM_BUSY_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAM_BUSY")
    field(SCAN, "I/O Intr")
    field(ZRST, "Idle")
    field(ZRVL, "0")
    field(ONST, "Busy")
    field(ONVL, "1")
}

# Exposure trigger signal
record(mbbi, "$(P)$(R)EXP_TRIGGER_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_EXP_TRIGGER")
    field(SCAN, "I/O Intr")
    field(ZRST, "Inactive")
    field(ZRVL, "0")
    field(ONST, "Active")
    field(ONVL, "1")
}

# Acquisition enable signal
record(mbbi, "$(P)$(R)ACQ_ENABLE_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_ACQ_ENABLE")
    field(SCAN, "I/O Intr")
    field(ZRST, "Inactive")
    field(ZRVL, "0")
    field(ONST, "Active")
    field(ONVL, "1")
}

# Camera serial number
record(longin, "$(P)$(R)SERIAL_NUMBER_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_SERIAL_NUMBER")
    field(SCAN, "I/O Intr")
}

# Camera hardware version
record(longin, "$(P)$(R)HARDWARE_VERSION_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_HARDWARE_VERSION")
    field(SCAN, "I/O Intr")
}

# Camera firmware version
record(longin, "$(P)$(R)FIRMWARE_VERSION_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_FIRMWARE_VERSION")
    field(SCAN, "I/O Intr")
}

# Camera connection state
record(bi, "$(P)$(R)CONNECTED_RBV")
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CONNECTED")
    field(SCAN, "I/O Intr")
	field(ZNAM, "Disconnected")
	field(ONAM, "Connected")
}

# Capture errors
record(longin, "$(P)$(R)CAPTURE_ERRORS_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_CAPTURE_ERRORS")
    field(SCAN, "I/O Intr")
}

# Buffer status
record(longin, "$(P)$(R)BUFFERS_READY_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_BUFFERS_READY")
    field(SCAN, "I/O Intr")
}

# Frame status errors
record(longin, "$(P)$(R)FRAME_STATUS_ERRORS_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_FRAME_STATUS_ERRORS")
    field(SCAN, "I/O Intr")
}

# The camera is an Edge
record(longin, "$(P)$(R)IS_EDGE_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_IS_EDGE")
    field(SCAN, "I/O Intr")
}

# Get image command
record(longout, "$(P)$(R)GET_IMAGE")
{
    field(DTYP, "asynInt32")
    field(OUT, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_GET_IMAGE")
}

# Frame wait faults
record(longin, "$(P)$(R)FRAME_WAIT_FAULTS_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_FRAME_WAIT_FAULTS")
    field(SCAN, "I/O Intr")
}

# Frames read by the poll function
record(longin, "$(P)$(R)POLL_GET_FRAMES_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_POLL_GET_FRAMES")
    field(SCAN, "I/O Intr")
}

# Invalid frames
record(longin, "$(P)$(R)INVALID_FRAMES_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_INVALID_FRAMES")
    field(SCAN, "I/O Intr")
}

# Buffers in use
record(longin, "$(P)$(R)BUFFERS_IN_USE_RBV") 
{
    field(DTYP, "asynInt32")
    field(INP, "@asyn($(PORT),$(ADDR),$(TIMEOUT))PCO_BUFFERS_IN_USE")
    field(SCAN, "I/O Intr")
}

